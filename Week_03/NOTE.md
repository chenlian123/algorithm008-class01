##### 递归的基本思想<br/>
递归- 某个函数直接或者间接的调用自身问题的求解过程，划分成许多相同性质的子问题的求解，而小的问题的求解
过程可以很容易的求出这些子问题的解就构成愿问题的解。
##### 递归算法解决问题的特点：<br/>

- 递归就是方法里调用自身。
- 在使用递增策略时，必须要有一个明确的递归结束条件，称为递归出口。
- 递归算法解题通常显得很简洁，但是运行效率低。
- 在递归调用的过程当中系统为每一层的返回点，局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。

##### 递归的经典示例：<br/>
计算阶乘<br/>
计算阶乘是递归程序设计的一个经典示例。计算某个数的阶乘就是用那个数去乘包括1在内的所有比它小的数。
例如，factorial(5)等价于`5*4*3*2*1`，而factorial(3)等价于`3*2*1`。<br/>
  阶乘的一个有趣特性是，某个数的阶乘等于起始数乘以比它小一的数的阶乘。例如factorial(5)等价于5*factorial(4)
  相同。
 ```
int factorial(int n){
    return n * factorial(n - 1);
}
 ```
这个函数的问题是，它会永远运行下去，因为它没有终止的地方，函数会连续不断的调用factorial。当计算到零时，
没有条件来停止它，所以它会继续调用零和负数的阶乘。因此我们的函数需要一个条件，告诉他如何停止，
由于小于1的数的阶乘没有任何意义，所以我们在计算到1的时候停止，并返回1的阶乘(即1)。因此，真正的递归函数类似于：
 ```
int factorial(int n){
    if(n == 1)
        return 1;
    else
      return n * 
factorial(n - 1);
}
 ```
可见，只要初始值大于零，这个函数就能够终止，停止的位置称为基线条件。基线条件是递归程序的最底层位置，在此
位置时没有必要再进行操作，可以直接返回一个结果。所有递归程序都必须至少拥有一个基线条件，而且必须确保他们最终会达到某个基线条件
 <br/> 
#### 斐波那契数列 <br/> 
斐波那契数列最开始用于描述兔子生长的数目时用上了这数列，从数学上，斐波那契数列是以递归的方法来定义：
这样斐波那契数列的递归程序就可以非常清晰的写出来了：
```
int Fibonacci(int n){
    if (n <= 1)  
        return n;  
    else  
        return Fibonacci(n-1) + Fibonacci(n-2);  
}
```
每一个递归程序都遵循相同都基本步骤：<br/>
- 初始化算法。递归程序通常需要一个开始时使用都种子值（seed value）。要完成此任务，可以向函数传递参数
，或者提供一个入口函数，这个函数是非递归都，但可以为递归计算设置种子值。
- 坚持要处理的当前值是否已经与基线条件相匹配，则进行处理并返回值。
- 使用更小的或更简单的子问题或多个子问题来重新定义答案。
- 对子问题运行算法。
- 将结果合并入答案的表达式。
- 返回结果。

#### 归纳法 <br/> 
数学归纳法：是一种数学证明方法，通常被用于证明某个给定命题在整个或者局部自然数范围内成立。
除了自然数意外，广义上的数学归纳法也可以用于证明一般良基结构。

#### 归纳法思维 <br/> 
有时候编写递归程序时难以获得更简单的子问题。不过，使用归纳定义的数据集可以令子问题的获得更为简单。
归纳定义的数据集时根据自身定义的数据结构，这叫做归纳定义。<br/> 
例如，链表就是根据其本身定义出来的。链表所包含的节点结构体由两部分构成：它所持有的数据，以及指向另一个节点结构体(或者是null，结束链表)的指针。
由于节点结构体内部包含有一个指向节点结构体的指针，所以称之为是归纳定义的。 <br/> 
使用归纳数据编写递归过程非常简单。注意，与我们的递归程序非常累死，链表的定义也包括一个基线条件--这里是null指针。
由于null指针会结束一个链表，所以我们也可以使用null指针条件作为基于链表的很多递归程序的基线条件。



#### 分治 <br/> 
分治的思想就是把大问题分解成小问题，解决小问题，再把小问题的解答合并得到大问题的解答
<br/>
##### 分治法的流程：
- 分解 将大规模的问题分解成若干个规模更小的但形式相同但子问题。
- 解决 如果当前问题的规模足够小 并可以直接解决的话，那么直接解决并返回解。否则，继续进行分解并递归求解分解后的子问题。
- 合并 将各个子问题进行合并，最终形成愿问题的解。<br/> 
分治法一般会采用递归法来进行实现，当然利用迭代法（比如for while）也是可以的。所以我们往往
看到的递归算法从广义上来说是分治法。无非就是有些递归算法将问题分解了若干个子问题问题，
然而有些递归算法将问题分解成一个子问题，有些称前者是分治法，后者为减治法。
还有一个非常重要的一点是递归算法中的边界条件的判定，只要我们想明白求解子问题过程中的边界条件，那么问题就会很清晰，并且很容易的写出程序来，否则模糊的边界条件，会导致整个递归算法进入到死循坏的地步。





#### 回溯 <br/>
回溯的思想就是在递归解决问题的过程中，遇到不满足条件的情况，返回上一层重新选择路径解决。 



















